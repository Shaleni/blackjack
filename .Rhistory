dBust <- sum(dealerCards)>21
pBlackjack <- sum(playerCards)==21
dBlackjack <- sum(dealerCards)==21
#if it was not a split hand, run as normal
if(is.null(splitPlayerCards)){
#Determine winner and assign money
#if player is bust, loses money
if(pBust){
amtLeft <- amtLeft - 1
numBust <- numBust +1
cat("Player Busted with",sum(playerCards), "try again\n")
} else if (dBlackjack){
if (!pBlackjack){
amtLeft <- amtLeft - 1
numLoss <- numLoss +1
cat("House got blackjack, player had",sum(playerCards),"\nTry again\n")
} else{
#if both get blackjack, no money exchanged
numTie <- numTie + 1
cat("House and player both got blackjack, push\n")
}
} else if (pBlackjack){
#player wins
amtLeft <- amtLeft + 2.5
numBlackJack <- numBlackJack + 1
cat("Player got Blackjack!!! House had",sum(dealerCards),"\nCongrats!\n")
} else if (dBust){
#player wins
amtLeft <- amtLeft + 2
numOtherWin <- numOtherWin + 1
cat("House busted with",sum(dealerCards),"\nYou had",sum(playerCards),"! Congrats!\n")
} else if (sum(playerCards)>sum(dealerCards)){
#player wins
amtLeft <- amtLeft + 2
numOtherWin <- numOtherWin + 1
cat("Player beat house,",sum(playerCards)," to ",sum(dealerCards),"\n")
} else if (sum(playerCards)==sum(dealerCards)){
#if both get same amount, no money exchanged
numTie <- numTie + 1
cat("House and player both got",sum(playerCards),", push\n")
}else{
#player loses
amtLeft <- amtLeft - 1
numLoss <- numLoss + 1
cat("House beat player, ",sum(dealerCards)," to ",sum(playerCards),"\n")
}
###################################
#output hands
cat("Dealer hand: ",dealerCards,"\n")
cat("Player hand: ",playerCards,"\n")
###################################
return(cbind(numBlackJack,numOtherWin,numTie,numLoss,numBust,totalBet,amtLeft))
} else{
cat("Have a split hand\n")
cat("Hand 1: ",playerCards,"\n")
cat("Hand 2: ",splitPlayerCards,"\n")
cat("Dealer hand: ",dealerCards,"\n")
#given a split hand:
#check each hand for an ace and a 10 value; this combination will only win the bet amount
#rather than the normal 1 1/2 times
#otherwise, call checkForWinner with each hand and return the combined result
}
}
# Player functions
# one function for each strategy
# Takes a card to add to the hand, and a boolean to create a new hand
# Returns a list containing the player's hand, and boolean if the player is standing
######################
######Strategy 1######
######################
#Never bust, i.e. never hit when >10
#set Ace to 11 when the other card is >5
#(lowest possible with an ace is 17)
playerS1 <- function(card, reset){
#initialize/reset card vector
if (reset){
playerCards <<- vector()
}
#check for 21, to hit, or to stay
#want to never bust, so only hit when <=11
#account for if an ace valued 11 is causing
#the total value of the hand to be >=11
playerCards <<- append(playerCards,card)
#check for the one case of ace and a card >=6
#only time ace would be 11
if(length(which(playerCards==-1))==1 && length(which(playerCards>=6))==1){
#set ace to 11
playerCards[which(playerCards==-1)] <- 11
}else {
#handle aces
#set aces to 1
#otherwise have 11 or 12 and won't hit
if(length(which(playerCards==-1))>=1){
#set aces to 1
playerCards[which(playerCards==-1)] <- 1
}
}
#check if busted and still have an ace that's 11 - change ace that was 11 to 1
if(sum(playerCards)>21 && length(which(playerCards==11))==1){
playerCards[which(playerCards==11)] <- 1
}
return(list(playerCards,sum(playerCards)>=11))
}
#blackjackSimulator.R
#version of blackjack.R that uses different files for the functions
setwd("C:/Users/shale_000/OneDrive/SMU/Fall2017/STAT 6324/blackjack")
######################
##Constant Functions##
######################
#shuffleCards, dealer, and checkForWinner do not change from simulation to simulation
#import shuffleCards
#args: vector of cards
#returns: list(shuffledcards vector, termination index)
source("shuffle.R")
#import dealer
#args: card to add to hand, boolean (T-create new hand|F-add to existing hand)
#returns: list(dealer's hand vector, boolean (T-dealer is standing|F-dealer's hand <16))
source("dealer.R")
#import checkForWinner
#args:
#returns:
#winnerVerbose contains print statements with dealer and player hands, outcome, and totals per game
#winner runs the same code without the print statements
source("winnerVerbose.R")
source("winner.R")
######################
######Player File#####
######################
#contains a player function for each strategy
#Each function has the same arguments/returns
#args: card to add to hand, boolean (T-create new hand|F-add to existing hand)
#returns: list(player's hand vector, boolean (T-player is standing|F-based on strategy))
source("player.R")
#################
##Generate Deck##
#################
#this is the base deck that will be shuffled when needed
#cards will not be changed
#one suit
cards <- c(2:10,10,10,10,-1)
names(cards) <- c(2:10,"J","Q","K","A")
#one deck (4 suits)
cards <- rep(cards,4)
#6 decks
cards <- rep(cards,6)
#######################
######Simulations######
#######################
s1 <- function(results,deck,terminate){
totalBet<-0
counter <- 1
#deal first card to player and dealer
playerS1(deck[counter],T)
counter <- counter + 1
dealer(deck[counter],T)
counter <- counter + 1
#go through the deck, last game is with the termination card
while(counter<=terminate){
totalBet <- totalBet +1
#deal second card to player and dealer
p<-playerS1(deck[counter],F)
counter <- counter + 1
d<-dealer(deck[counter],F)
counter <- counter + 1
#finish hands of player and dealer
while(!(p[[2]])){
p<-playerS1(deck[counter],F)
counter <- counter + 1
}
while(!unlist(d[2])){
d<-dealer(deck[counter],F)
counter <- counter + 1
}
#get the results of the game
r<-checkForWinnerVerbose(unlist(p[1]),unlist(d[1]))
results <- results+r
#deal first card of next game to player and dealer
p<-playerS1(deck[counter],T)
counter <- counter + 1
d<-dealer(deck[counter],T)
counter <- counter + 1
}
results[6] <- totalBet
return(results)
}
#######################
##Running Simulations##
#######################
#runs the different simulations.
#takes an argument x that shows which strategy to run
#1-6: strategies 1-6
#7-12: strategies 1-6 with splitting
#13-18: strategies 1-6 with splitting and doubling down
runSimulations <- function(x){
#initialize values to bind to return
numBlackJack <- numOtherWin <- 0
numTie <- numLoss<-numBust <-0
totalBet <-amtLeft <-0
#get the shuffled deck and termination card
deck <- shuffleCards(cards)
terminate <- deck[2]
terminate <- unlist(terminate)
deck <- deck[1]
deck<-unlist(deck)
results<-(cbind(numBlackJack,numOtherWin,numTie,numLoss,numBust,totalBet,amtLeft))
if(x==1){
results <- s1(results,deck,terminate)
}
return(results)
}
result <- runSimulations(1)
finalResults <- rowSums(sapply(1:10,function(i) sapply(X=runSimulations(1),FUN="+")))
names(finalResults) <- c("BlackJack","OtherWin","Tie","Loss","Bust","TotalBet","AmtLeft")
#finalResultsProb <- finalResults/finalResults[6]
finalResults
# Determine Game Winner
# Takes the player's hand, the dealer's hand, split hand (optional)
# Returns a list containing the dealer's hand, and boolean if the dealer is standing
checkForWinnerVerbose<-function(playerCards,dealerCards,splitPlayerCards){
#initalize values
numBlackJack <- numOtherWin <- 0
numTie <- numLoss<- numBust <-0
amtLeft <- totalBet <-0
#set flags
pBust <- sum(playerCards)>21
dBust <- sum(dealerCards)>21
pBlackjack <- sum(playerCards)==21
dBlackjack <- sum(dealerCards)==21
#if it was not a split hand, run as normal
if(missing(splitPlayerCards)){
#Determine winner and assign money
#if player is bust, loses money
if(pBust){
amtLeft <- amtLeft - 1
numBust <- numBust +1
cat("Player Busted with",sum(playerCards), "try again\n")
} else if (dBlackjack){
if (!pBlackjack){
amtLeft <- amtLeft - 1
numLoss <- numLoss +1
cat("House got blackjack, player had",sum(playerCards),"\nTry again\n")
} else{
#if both get blackjack, no money exchanged
numTie <- numTie + 1
cat("House and player both got blackjack, push\n")
}
} else if (pBlackjack){
#player wins
amtLeft <- amtLeft + 2.5
numBlackJack <- numBlackJack + 1
cat("Player got Blackjack!!! House had",sum(dealerCards),"\nCongrats!\n")
} else if (dBust){
#player wins
amtLeft <- amtLeft + 2
numOtherWin <- numOtherWin + 1
cat("House busted with",sum(dealerCards),"\nYou had",sum(playerCards),"! Congrats!\n")
} else if (sum(playerCards)>sum(dealerCards)){
#player wins
amtLeft <- amtLeft + 2
numOtherWin <- numOtherWin + 1
cat("Player beat house,",sum(playerCards)," to ",sum(dealerCards),"\n")
} else if (sum(playerCards)==sum(dealerCards)){
#if both get same amount, no money exchanged
numTie <- numTie + 1
cat("House and player both got",sum(playerCards),", push\n")
}else{
#player loses
amtLeft <- amtLeft - 1
numLoss <- numLoss + 1
cat("House beat player, ",sum(dealerCards)," to ",sum(playerCards),"\n")
}
###################################
#output hands
cat("Dealer hand: ",dealerCards,"\n")
cat("Player hand: ",playerCards,"\n")
###################################
return(cbind(numBlackJack,numOtherWin,numTie,numLoss,numBust,totalBet,amtLeft))
} else{
cat("Have a split hand\n")
cat("Hand 1: ",playerCards,"\n")
cat("Hand 2: ",splitPlayerCards,"\n")
cat("Dealer hand: ",dealerCards,"\n")
#given a split hand:
#check each hand for an ace and a 10 value; this combination will only win the bet amount
#rather than the normal 1 1/2 times
#otherwise, call checkForWinner with each hand and return the combined result
}
}
#blackjackSimulator.R
#version of blackjack.R that uses different files for the functions
setwd("C:/Users/shale_000/OneDrive/SMU/Fall2017/STAT 6324/blackjack")
######################
##Constant Functions##
######################
#shuffleCards, dealer, and checkForWinner do not change from simulation to simulation
#import shuffleCards
#args: vector of cards
#returns: list(shuffledcards vector, termination index)
source("shuffle.R")
#import dealer
#args: card to add to hand, boolean (T-create new hand|F-add to existing hand)
#returns: list(dealer's hand vector, boolean (T-dealer is standing|F-dealer's hand <16))
source("dealer.R")
#import checkForWinner
#args:
#returns:
#winnerVerbose contains print statements with dealer and player hands, outcome, and totals per game
#winner runs the same code without the print statements
source("winnerVerbose.R")
source("winner.R")
######################
######Player File#####
######################
#contains a player function for each strategy
#Each function has the same arguments/returns
#args: card to add to hand, boolean (T-create new hand|F-add to existing hand)
#returns: list(player's hand vector, boolean (T-player is standing|F-based on strategy))
source("player.R")
#################
##Generate Deck##
#################
#this is the base deck that will be shuffled when needed
#cards will not be changed
#one suit
cards <- c(2:10,10,10,10,-1)
names(cards) <- c(2:10,"J","Q","K","A")
#one deck (4 suits)
cards <- rep(cards,4)
#6 decks
cards <- rep(cards,6)
#######################
######Simulations######
#######################
s1 <- function(results,deck,terminate){
totalBet<-0
counter <- 1
#deal first card to player and dealer
playerS1(deck[counter],T)
counter <- counter + 1
dealer(deck[counter],T)
counter <- counter + 1
#go through the deck, last game is with the termination card
while(counter<=terminate){
totalBet <- totalBet +1
#deal second card to player and dealer
p<-playerS1(deck[counter],F)
counter <- counter + 1
d<-dealer(deck[counter],F)
counter <- counter + 1
#finish hands of player and dealer
while(!(p[[2]])){
p<-playerS1(deck[counter],F)
counter <- counter + 1
}
while(!unlist(d[2])){
d<-dealer(deck[counter],F)
counter <- counter + 1
}
#get the results of the game
r<-checkForWinnerVerbose(unlist(p[1]),unlist(d[1]))
results <- results+r
#deal first card of next game to player and dealer
p<-playerS1(deck[counter],T)
counter <- counter + 1
d<-dealer(deck[counter],T)
counter <- counter + 1
}
results[6] <- totalBet
return(results)
}
#######################
##Running Simulations##
#######################
#runs the different simulations.
#takes an argument x that shows which strategy to run
#1-6: strategies 1-6
#7-12: strategies 1-6 with splitting
#13-18: strategies 1-6 with splitting and doubling down
runSimulations <- function(x){
#initialize values to bind to return
numBlackJack <- numOtherWin <- 0
numTie <- numLoss<-numBust <-0
totalBet <-amtLeft <-0
#get the shuffled deck and termination card
deck <- shuffleCards(cards)
terminate <- deck[2]
terminate <- unlist(terminate)
deck <- deck[1]
deck<-unlist(deck)
results<-(cbind(numBlackJack,numOtherWin,numTie,numLoss,numBust,totalBet,amtLeft))
if(x==1){
results <- s1(results,deck,terminate)
}
return(results)
}
result <- runSimulations(1)
finalResults <- rowSums(sapply(1:10,function(i) sapply(X=runSimulations(1),FUN="+")))
names(finalResults) <- c("BlackJack","OtherWin","Tie","Loss","Bust","TotalBet","AmtLeft")
#finalResultsProb <- finalResults/finalResults[6]
finalResults
#blackjackSimulator.R
#version of blackjack.R that uses different files for the functions
setwd("C:/Users/shale_000/OneDrive/SMU/Fall2017/STAT 6324/blackjack")
######################
##Constant Functions##
######################
#shuffleCards, dealer, and checkForWinner do not change from simulation to simulation
#import shuffleCards
#args: vector of cards
#returns: list(shuffledcards vector, termination index)
source("shuffle.R")
#import dealer
#args: card to add to hand, boolean (T-create new hand|F-add to existing hand)
#returns: list(dealer's hand vector, boolean (T-dealer is standing|F-dealer's hand <16))
source("dealer.R")
#import checkForWinner
#args:
#returns:
#winnerVerbose contains print statements with dealer and player hands, outcome, and totals per game
#winner runs the same code without the print statements
source("winnerVerbose.R")
source("winner.R")
######################
######Player File#####
######################
#contains a player function for each strategy
#Each function has the same arguments/returns
#args: card to add to hand, boolean (T-create new hand|F-add to existing hand)
#returns: list(player's hand vector, boolean (T-player is standing|F-based on strategy))
source("player.R")
#################
##Generate Deck##
#################
#this is the base deck that will be shuffled when needed
#cards will not be changed
#one suit
cards <- c(2:10,10,10,10,-1)
names(cards) <- c(2:10,"J","Q","K","A")
#one deck (4 suits)
cards <- rep(cards,4)
#6 decks
cards <- rep(cards,6)
#######################
######Simulations######
#######################
s1 <- function(results,deck,terminate){
totalBet<-0
counter <- 1
#deal first card to player and dealer
playerS1(deck[counter],T)
counter <- counter + 1
dealer(deck[counter],T)
counter <- counter + 1
#go through the deck, last game is with the termination card
while(counter<=terminate){
totalBet <- totalBet +1
#deal second card to player and dealer
p<-playerS1(deck[counter],F)
counter <- counter + 1
d<-dealer(deck[counter],F)
counter <- counter + 1
#finish hands of player and dealer
while(!(p[[2]])){
p<-playerS1(deck[counter],F)
counter <- counter + 1
}
while(!unlist(d[2])){
d<-dealer(deck[counter],F)
counter <- counter + 1
}
#get the results of the game
r<-checkForWinnerVerbose(unlist(p[1]),unlist(d[1]))
results <- results+r
#deal first card of next game to player and dealer
p<-playerS1(deck[counter],T)
counter <- counter + 1
d<-dealer(deck[counter],T)
counter <- counter + 1
}
results[6] <- totalBet
return(results)
}
#######################
##Running Simulations##
#######################
#runs the different simulations.
#takes an argument x that shows which strategy to run
#1-6: strategies 1-6
#7-12: strategies 1-6 with splitting
#13-18: strategies 1-6 with splitting and doubling down
runSimulations <- function(x){
#initialize values to bind to return
numBlackJack <- numOtherWin <- 0
numTie <- numLoss<-numBust <-0
totalBet <-amtLeft <-0
#get the shuffled deck and termination card
deck <- shuffleCards(cards)
terminate <- deck[2]
terminate <- unlist(terminate)
deck <- deck[1]
deck<-unlist(deck)
results<-(cbind(numBlackJack,numOtherWin,numTie,numLoss,numBust,totalBet,amtLeft))
if(x==1){
results <- s1(results,deck,terminate)
}
return(results)
}
result <- runSimulations(1)
finalResults <- rowSums(sapply(1:2,function(i) sapply(X=runSimulations(1),FUN="+")))
names(finalResults) <- c("BlackJack","OtherWin","Tie","Loss","Bust","TotalBet","AmtLeft")
#finalResultsProb <- finalResults/finalResults[6]
finalResults
